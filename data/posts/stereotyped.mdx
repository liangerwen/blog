---
title: 经典八股文
---

## UDP 和 TCP 区别

UDP（用户数据报协议）和 TCP（传输控制协议）是两种互联网协议，用于在计算机之间进行数据通信。它们之间的主要区别包括：

**连接性：**

- TCP 是一种面向连接的协议，意味着在数据传输之前，必须建立一个连接，然后在传输结束后关闭连接。这种连接是可靠的，即在数据传输过程中，数据包会按照顺序到达，且不会丢失或损坏。
- UDP 是一种无连接的协议，数据包可以直接发送到目标，而不需要建立连接。UDP 不提供像 TCP 那样的可靠性保证，数据包可能会丢失、乱序或重复。

**可靠性：**

- TCP 提供可靠的数据传输，它使用序号、确认和重传机制来确保数据的完整性和顺序性。如果数据包丢失或损坏，TCP 会重新发送。
- UDP 不提供可靠性保证，因为它没有确认、重传或流量控制机制。因此，UDP 适用于那些能够容忍一定程度数据丢失的应用，比如实时视频流或音频流。

**效率：**

- 由于 TCP 提供了较多的功能（如流量控制、拥塞控制等），因此在数据传输时可能会产生一定的开销，包括较高的头部开销和更多的传输延迟。
- UDP 的头部开销较小，数据传输速度较快。因此，UDP 通常用于那些对传输速度要求较高，而对数据完整性要求较低的应用。

**应用：**

- TCP 通常用于需要可靠数据传输的应用，比如网页浏览、文件传输、电子邮件等。
- UDP 通常用于实时应用，如音频、视频流传输、在线游戏等，因为它们对传输速度和实时性要求较高，而可以容忍一定程度的数据丢失。

## https http http2 区别

HTTP（超文本传输协议）、HTTPS（安全超文本传输协议）和 HTTP/2 是用于在网络上传输数据的协议，它们之间的主要区别包括：

**安全性：**

- HTTP：是一种明文传输协议，数据在传输过程中是未加密的，因此容易受到中间人攻击和窃听。
- HTTPS：通过使用 SSL/TLS 协议对数据进行加密，提供了更高的安全性。通过公钥加密、私钥解密的方式，确保了数据在传输过程中的机密性和完整性。

**加密方式：**

- HTTP：不涉及加密，数据以明文形式传输。
- HTTPS：使用 SSL/TLS 协议对通信进行加密，包括对称加密和非对称加密等技术，确保通信的机密性和完整性。

**端口号：**

- HTTP：默认使用端口 80 进行通信。
- HTTPS：默认使用端口 443 进行通信。

**性能优化：**

- HTTP/2：是 HTTP 的升级版本，旨在提高网页加载速度和性能。HTTP/2 采用了多路复用技术，允许多个请求/响应在同一个连接上同时进行，减少了连接建立的开销和减少了延迟。此外，HTTP/2 还支持头部压缩和服务器推送等功能，进一步提高了性能。

**协议特性：**

- HTTP：是一种文本协议，每个请求/响应都是明文的，头部信息较为冗长。
- HTTPS：除了加密外，与 HTTP 基本一致，只是通过 SSL/TLS 层增加了加密和身份验证功能。
- HTTP/2：在 HTTP/1.x 的基础上进行了优化和改进，包括多路复用、头部压缩、服务器推送等特性，提高了性能和效率。

总的来说，HTTP 和 HTTPS 的主要区别在于安全性，而 HTTP/2 相比于 HTTP/1.x 则在性能和效率上有较大提升。

## TCP 三次握手 四次挥手

TCP（传输控制协议）是一种面向连接的协议，它使用三次握手来建立连接，四次挥手来关闭连接。

### 三次握手（TCP 连接建立过程）：

**客户端发送 SYN 报文：**

- 客户端首先向服务器发送一个 SYN（同步）报文，其中包含一个初始序列号（ISN），并设置 SYN 标志位为 1。

**服务器回应 SYN+ACK 报文：**

- 服务器收到客户端的 SYN 报文后，会回应一个同时带有 SYN 和 ACK（确认）标志位的报文，确认收到客户端的 SYN 报文，并发送自己的初始序列号（ISN）。

**客户端发送 ACK 报文：**

- 客户端收到服务器的 SYN+ACK 报文后，会再次发送一个确认报文，其中 ACK 标志位为 1，用于确认服务器的 SYN 报文。

此时，连接建立成功，客户端和服务器可以开始传输数据。

### 四次挥手（TCP 连接关闭过程）：

**客户端发送 FIN 报文：**

- 客户端向服务器发送一个带有 FIN（结束）标志位的报文，表示客户端已经完成数据传输任务，希望关闭连接。

**服务器回应 ACK 报文：**

- 服务器收到客户端的 FIN 报文后，会发送一个确认报文，确认收到客户端的 FIN 报文。

**服务器发送 FIN 报文：**

- 服务器在关闭前，也可能还有数据需要传输，所以在确认客户端的 FIN 后，会等待一段时间，继续向客户端发送数据。当服务器确定数据传输完成后，会向客户端发送一个带有 FIN 标志位的报文，表示服务器已经准备好关闭连接。

**客户端回应 ACK 报文：**

- 客户端收到服务器的 FIN 报文后，会发送一个确认报文，确认收到服务器的 FIN 报文。

此时，连接关闭完成，双方的连接状态均进入 CLOSED 状态。

总结：

- 三次握手确保双方都能够正常收发数据，建立可靠的连接。
- 四次挥手则保证双方在关闭连接时，能够完整地传输已有的数据并正确地关闭连接。

## 内存泄漏有哪些情况

JavaScript 内存泄漏通常指的是由于程序中的对象无法被正确释放而导致内存占用持续增加的情况。这种情况可能会导致程序性能下降，甚至最终导致浏览器崩溃。下面是一些常见的 JavaScript 内存泄漏情况：

**未及时清理引用：**

- 当一个对象不再使用时，如果仍然保持着对该对象的引用，即使该对象已经不再需要，它也不会被垃圾回收机制清理，导致内存泄漏。

**事件监听器未移除：**

- 当在 DOM 元素上添加事件监听器时，如果在元素被移除之前未将事件监听器移除，那么该元素及其相关的对象（例如闭包、回调函数等）将无法被垃圾回收，导致内存泄漏。

**定时器未清除：**

- 当使用`setTimeout()`或`setInterval()`创建定时器时，如果未及时清除这些定时器，即使页面已经关闭或者相关对象已经不再需要，定时器仍然会持续运行，导致内存泄漏。

**闭包：**

- 在 JavaScript 中，闭包是一种特殊的情况，它使得包含函数的作用域中的变量可以在包含函数执行完成后仍然被内部函数访问。如果闭包中保留了对外部作用域中对象的引用，并且外部对象不再需要时，这些对象将无法被垃圾回收，从而导致内存泄漏。

**循环引用：**

- 当两个或多个对象相互引用，并且这些引用形成一个闭环时，即使这些对象已经不再需要，它们也不会被垃圾回收。这种情况通常发生在对象间相互引用，但是没有任何对象引用它们的情况。

**大型数据结构未释放：**

- 如果创建了大型数据结构（例如大型数组或对象），并且在程序执行过程中不再需要这些数据结构，但是没有正确释放它们，就会造成内存泄漏。

**全局变量：**

- 如果将对象或数据存储在全局变量中，而这些数据在程序执行过程中不再需要，但是这些全局变量仍然存在，就会导致内存泄漏。

为了避免 JavaScript 内存泄漏，开发者应该在编写代码时注意及时释放不再需要的对象、清除未使用的事件监听器和定时器、避免循环引用等。同时，可以使用浏览器开发者工具中的内存分析工具来检测和定位内存泄漏问题。

## 原型链/继承方式

## get 和 post 区别

GET 和 POST 是 HTTP 协议中用于客户端向服务器发送请求的两种主要方法。它们之间的主要区别如下：

**数据传输方式：**

- GET：通过 URL 参数传递数据。GET 请求的参数会附加在 URL 的末尾，以查询字符串的形式出现，例如：`http://example.com/api?key1=value1&key2=value2`。因此，GET 请求的数据会暴露在 URL 中，可以在浏览器的地址栏中直接看到。
- POST：通过 HTTP 请求的主体传递数据。POST 请求的数据在 HTTP 请求的主体中进行传输，而不会暴露在 URL 中，因此更适合传输敏感数据或大量数据。

**数据长度限制：**

- GET：由于 GET 请求的参数直接附加在 URL 中，所以对 URL 的长度有限制。不同的浏览器和服务器对 URL 长度的限制可能有所不同，但一般来说是有限制的，通常在几千个字符以内。
- POST：由于 POST 请求的数据在 HTTP 请求的主体中传输，所以理论上没有数据长度限制。但是实际上，服务器和浏览器都会设置对 POST 请求的数据大小有一定限制，超过限制可能会导致截断或错误。

**数据安全性：**

- GET：由于 GET 请求的参数暴露在 URL 中，所以不适合传输敏感数据，因为敏感数据会被直接暴露在浏览器的地址栏中，容易被窥视。
- POST：由于 POST 请求的数据在 HTTP 请求的主体中传输，相比 GET 请求更安全，适合传输敏感数据。

**缓存处理：**

- GET：GET 请求可被缓存，因为 GET 请求的数据是在 URL 中明文传递的，如果相同的 GET 请求再次发送，浏览器可以直接从缓存中获取数据而不必向服务器发出请求。
- POST：POST 请求默认不可缓存，因为 POST 请求的数据是在 HTTP 请求的主体中传输的，而且 POST 请求通常会对服务器端数据进行修改，因此不应该缓存 POST 请求的响应。

总结来说，GET 适用于传输少量且不敏感的数据，适合获取数据的请求；而 POST 适用于传输大量数据或敏感数据，适合修改数据的请求。在选择 GET 和 POST 时，需根据具体的需求和数据特性进行选择。

## 301 302 区别

301 和 302 是 HTTP 状态码，用于指示 HTTP 重定向的不同类型。它们之间的主要区别在于重定向的性质和搜索引擎的行为。

**301 Moved Permanently (永久重定向)：**

- 当服务器返回状态码为 301 时，它指示请求的资源已被永久移动到新的位置，并且以后应使用新的 URL 来访问该资源。
- 浏览器在接收到 301 响应后，会缓存重定向的目标 URL，以后再次访问原始 URL 时，会直接跳转到新的 URL，而不会再发送请求到原始 URL。
- 搜索引擎会将原始 URL 中的权重转移到新的 URL 上，认为这是同一资源的永久移动。

**302 Found (临时重定向)：**

- 当服务器返回状态码为 302 时，它指示请求的资源已被临时移动到新的位置。客户端应该继续使用原始 URL 来访问该资源。
- 浏览器在接收到 302 响应后，会暂时跳转到新的 URL，但不会更新书签或缓存。下次访问时仍然会发送请求到原始 URL。
- 搜索引擎不会将原始 URL 中的权重转移到新的 URL 上，而是保留原始 URL 的权重。

总结：

- 301 表示永久性移动，告诉客户端将原始 URL 永久重定向到新的 URL，搜索引擎会更新索引。
- 302 表示临时移动，告诉客户端将原始 URL 暂时重定向到新的 URL，搜索引擎不会更新索引。

## react diff

传统 diff 算法通过循环递归对节点进行依次对比，复杂度过高，为了降低算法复杂度，diff 遵循了 3 个层级的优化策略：

只进行同层比较。
新、旧节点的 type 不同，直接删除旧节点，创建新节点。
通过 key 来复用节点。

从 Diff 的入口函数 reconcileChildFibers 出发，判断子元素的类型，若不是数组进入单节点 diff，否则进入多节点 diff
单节点 diff：先判断 key 是否相同，

如果 key 相同，再看 type

type 相同，复用；
type 不同，全部删掉（包括它和它的兄弟元素，因为既然 key 一样，唯一的可能性都不能复用，则剩下的 fiber 都没有机会了）；

如果 key 不同，只删除该 child，再找到它的兄弟节点（child.silbing）的 key，直到找到 key 相同的节点，再同上操作

多节点 diff：归纳只有 3 种情况，更新节点、增减节点、位置变化，由于是单向的链表（newChildren[0]与 fiber 比较，newChildren[1]与 fiber.sibling 比较），所以不能像 vue 一样用双指针遍历，所以这里逻辑要经过两轮遍历：

第一轮遍历：比较 key，

可复用，继续遍历 (新节点 i++，老节点 child.silbing)，
不可复用，就停止第一轮遍历，进入第二轮遍历，有 2 种不可复用的情况：

key 不同，直接停止

key 相同，type 不同，标记删除，停止

第二轮遍历：

老节点遍历完了，新节点还有，则将剩下的新节点插入
新节点遍历完了，老节点还有，则将剩下的老节点删除
新老节点都还有，则移动顺序，这是 diff 算法最精髓也是最难懂的部分，规则：遍历新节点，每个新节点有 2 个 index，一个 index 表示它在旧节点的位置，另一个 index 表示遍历中遇到的最大旧节点的位置，用 oldIndex 和 maxIndex 表示

当 oldIndex > maxIndex 时，将 oldIndex 的值赋值给 maxIndex
当 oldIndex = maxIndex 时，不操作
当 oldIndex < maxIndex 时，将当前节点移动到 index 的位置

## BFC 清除浮动

BFC（块级格式化上下文）是 CSS 中的一个概念，用于控制盒子如何布局、定位其子元素，以及与其他元素的交互。在某些情况下，可以利用 BFC 来清除浮动的影响，解决父元素因为子元素浮动导致的高度塌陷问题。

清除浮动的方法之一就是触发父元素的 BFC 特性。通过让父元素成为 BFC，可以使其包含浮动元素，从而不受浮动元素的影响，避免高度塌陷问题。常见的触发 BFC 的方式有以下几种：

**使用`overflow`属性：**

- 设置父元素的`overflow`属性为`auto`、`hidden`或`scroll`，可以触发父元素的 BFC。

```css
.parent {
  overflow: hidden; /* 或者 auto 或 scroll */
}
```

**使用`display`属性：**

- 设置父元素的`display`属性为`inline-block`、`table-cell`、`table-caption`、`table`、`flex`或`grid`，也可以触发父元素的 BFC。

```css
.parent {
  display: inline-block; /* 或者 table-cell、table-caption、table、flex、grid */
}
```

**使用`float`属性：**

- 如果父元素也设置了`float`属性，则会触发 BFC。

```css
.parent {
  float: left; /* 或 right */
}
```

**使用`position`属性：**

- 设置父元素的`position`属性为`absolute`、`fixed`、`sticky`，也可以触发 BFC。

```css
.parent {
  position: relative; /* 或 absolute、fixed、sticky */
}
```

**使用`clear`属性：**

- 设置一个空的`clear`元素，可以触发其父元素的 BFC。

```html
<div class="parent">
  <div class="float-left">浮动元素</div>
  <div class="clear"></div>
</div>

.clear { clear: both; }
```

以上这些方法可以单独使用，也可以结合使用，具体根据布局的需求来选择适合的方法。触发父元素的 BFC 可以有效地清除浮动，避免布局问题的发生。

## 动画 animation transition transform keyframes element.animate requestAnimationFrame

这是一些在前端开发中常用的动画相关的技术和 API：

**CSS 动画：**

- CSS 动画是通过 CSS 样式来定义动画效果的。可以使用`@keyframes`规则定义关键帧，然后通过`animation`属性将动画应用到元素上。示例：

```css
@keyframes myAnimation {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}

.element {
  animation: myAnimation 1s ease-in-out forwards;
}
```

**CSS 过渡：**

- CSS 过渡用于在元素的属性发生变化时，以动画的形式平滑地过渡到新的状态。可以使用`transition`属性定义过渡效果。示例：

```css
.element {
  transition: opacity 1s ease-in-out;
}

.element:hover {
  opacity: 0.5;
}
```

**CSS 变换：**

- CSS 变换用于对元素进行平移、旋转、缩放和倾斜等变换操作。可以使用`transform`属性定义变换效果。示例：

```css
.element {
  transform: translate(100px, 100px) rotate(45deg) scale(2);
}
```

**JavaScript 动画 API：**

- `element.animate()`: 这是 JavaScript 的动画 API，用于创建和控制 CSS 动画。它可以通过 JavaScript 直接创建和控制动画效果。

```javascript
const element = document.querySelector(".element");
element.animate(
  { opacity: [0, 1], transform: ["scale(0)", "scale(1)"] },
  { duration: 1000, easing: "ease-in-out", fill: "forwards" }
);
```

**requestAnimationFrame：**

- `requestAnimationFrame()`方法是一个用于动画的 JavaScript API，它告诉浏览器您希望执行动画并请求浏览器调用指定的函数在下一次重绘之前更新动画。与`setTimeout()`相比，`requestAnimationFrame()`更有效率，并且会在适当的时机调用动画函数，以便更好地与浏览器的渲染进程同步。示例：

```javascript
function animate() {
  // 更新动画状态
  // 递归调用requestAnimationFrame
  requestAnimationFrame(animate);
}
// 启动动画
animate();
```

这些技术和 API 可以根据具体的需求和场景来选择使用，用于创建各种各样的动画效果，使得网页交互更加生动和吸引人。

## svg 和 canvas

SVG（Scalable Vector Graphics，可缩放矢量图形）和 Canvas 是两种用于在网页上绘制图形的不同技术。

**SVG（Scalable Vector Graphics）：**

**矢量图形：** SVG 使用矢量图形描述语言来定义图形，它们由一系列的点、线、曲线等数学描述的形状组成。这使得 SVG 图形可以无损地进行缩放和放大，而不会失去清晰度。

**基于 XML：** SVG 是一种基于 XML 的图像格式，SVG 文件是可读的文本文件，可以使用文本编辑器进行编辑和调整。每个图形元素都是 DOM 元素，可以通过 JavaScript 和 CSS 进行操作和样式设置。

**交互性强：** 由于 SVG 图形是 DOM 元素，因此可以与其他 HTML 元素一样添加事件监听器，使得 SVG 元素具有丰富的交互性和动态性。

**复杂图形处理：** SVG 适用于绘制复杂的图形、图表、地图等需要高保真度和交互性的场景。

**Canvas：**

**位图绘制：** Canvas 是一个 HTML5 元素，它提供了一块画布，允许使用 JavaScript 绘制位图图形。Canvas 绘制的图形是以像素为单位的，所以缩放会导致图像的失真。

**绘图 API：** 通过 JavaScript 绘制图形，Canvas 提供了绘制路径、图像、文本等的 API，以及颜色、阴影等样式设置。

**动态更新：** 由于 Canvas 绘制的图形是基于像素的，它适用于需要频繁更新、动态变化的场景，如动画、游戏等。

**性能：** Canvas 绘制的图形是位图，因此在处理大量图形和复杂图形时，Canvas 通常具有更好的性能。

综上所述，选择 SVG 还是 Canvas 取决于具体的应用场景和需求。SVG 适用于静态和交互性强的图形，而 Canvas 适用于动态更新和性能要求较高的图形。

## 前端性能优化

前端性能优化是指通过优化网页的加载速度、渲染性能和交互响应等方面来提高用户体验的一系列技术和策略。以下是一些常见的前端性能优化方法：

**压缩和合并文件：**

- 压缩 JavaScript、CSS 和 HTML 文件，减小文件体积。
- 将多个小文件合并成一个大文件，减少网络请求次数。

**使用 CDN 加速：**

- 将静态资源（如图片、CSS、JavaScript 文件）托管到内容分发网络（CDN），加速资源的传输和加载速度。

**使用缓存：**

- 利用浏览器缓存机制缓存静态资源，减少重复加载。
- 设置适当的缓存策略，如设置 Expires 或 Cache-Control 头，利用浏览器缓存静态资源。

**优化图片：**

- 使用合适的图片格式，如 JPEG、PNG、WebP 等。
- 压缩图片文件大小，减少加载时间。
- 使用响应式图片，根据设备和屏幕大小加载不同尺寸的图片。

**延迟加载：**

- 将不是立即需要的资源延迟加载，如图片懒加载、异步加载 JavaScript 等。

**减少重绘和重排：**

- 避免频繁修改 DOM 结构，合并多次操作，减少浏览器的重排和重绘。
- 使用 CSS 动画代替 JavaScript 实现动画效果，使用 transform 和 opacity 属性开启 GPU 加速。

**代码优化：**

- 减少 JavaScript 的执行时间，避免使用过多的循环、递归和复杂的操作。
- 使用事件委托来减少事件监听器的数量。
- 避免过度使用全局变量，减少内存占用。

**预加载和预渲染：**

- 使用`<link rel="preload">`标签预加载关键资源，提前获取资源并放入浏览器缓存中。
- 使用`<link rel="prerender">`标签在后台预取页面，提前渲染页面，加快页面切换速度。

**性能监控和分析：**

- 使用工具监控网页的性能指标，如页面加载时间、资源加载时间、首次渲染时间等。
- 分析性能数据，找出性能瓶颈和优化点，持续改进网站性能。

通过以上方法，可以有效提高网站的加载速度和性能，提升用户体验。但需要根据具体的项目需求和情况选择合适的优化策略，并持续关注和改进网站性能。

## 垃圾回收机制 v8/浏览器

<a href="https://segmentfault.com/a/1190000020281167" target="_blank">
  垃圾回收机制 v8/浏览器
</a>

## 引用类型和基础类型存储方式

JavaScript 中的数据类型分为基本类型和引用类型两种，它们在内存中的存储方式有所不同。

**基本类型（Primitive Types）：**

- JavaScript 中的基本类型包括：Undefined、Null、Boolean、Number 和 String。
- 基本类型的值直接存储在变量访问的位置。当创建一个基本类型的变量时，JavaScript 引擎会在内存中为其分配一块固定大小的空间，将其值存储在这块空间中。
- 当基本类型的值被赋值给另一个变量时，实际上是将原始值直接复制到新变量的位置，这两个变量之间相互独立，互不影响。

**引用类型（Reference Types）：**

- JavaScript 中的引用类型包括：Object、Array、Function 等。
- 引用类型的值存储在堆内存中，而变量则存储对该对象的引用（内存地址）。
- 当创建一个引用类型的变量时，JavaScript 引擎会为其分配一块内存空间，并将其地址存储在变量访问的位置。这意味着变量实际上存储的是对对象的引用，而不是对象本身。
- 当将一个引用类型的变量赋值给另一个变量时，实际上是将原始变量存储的地址复制到新变量，这两个变量将引用同一个对象，因此它们指向同一块内存空间，对一个变量的操作会影响到另一个变量。

基本类型的存储方式简单直接，值存储在变量访问的位置，而引用类型的存储方式更加复杂，值存储在堆内存中，变量存储对对象的引用。因此，在处理引用类型时需要注意变量之间的引用关系，以避免出现意外的结果。

## react diff

1. 当新节点为单节点时
    - 判断 key 是否相同
        - key 相同 判断 type 是否相同 同则复用老节点不同删除老节点并移动到下一个老节点比对
        - 不同则删除所有老节点
    - 创建新节点

2. 当新节点为多节点时
    - 遍历新老节点 判断复用性（key和type） 如果可复用则比对下一个否则跳出
    - 都遍历完说明都复用
    - 新的有老的没有说明只剩新增 标记新的其他为新增
    - 新的没有老的有说明只剩删除 标记老的其他为删除
    - 新老都有说明有移动情况 maxindex和oldindex的算法
